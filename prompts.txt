Disclaimer:  I have used gemini to refine my prompts so that maximum utilization can be done with minimum number of tokens used possible.
Prompt - 1
Take input from this image, 
Create a prompt which is well thought out, doesnt miss anything. 
Make sure here are no functional as well as design oversights, use sqlite for storing data.
 Make the prompt precise and well organized.

Prompt - 2
Project Title: Full-Stack Product Feedback Board

Overall Objective:
Create a full-stack web application that functions as a public product feedback board. Users should be able to submit feedback, view all submitted feedback sorted by popularity, upvote feedback items, and comment on them.

Technology Stack
Frontend: React (using Vite for setup) with simple CSS for styling. No complex UI libraries are needed.

Backend: Node.js with Express.js.

Database: SQLite.

API: Create a RESTful API for communication between the frontend and backend.

Backend (Server) Requirements
1. Database Schema (SQLite)
Define three tables:

feedback table:

id: INTEGER PRIMARY KEY AUTOINCREMENT

title: TEXT NOT NULL

description: TEXT NOT NULL

user_email: TEXT NOT NULL

created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP

upvotes table:

id: INTEGER PRIMARY KEY AUTOINCREMENT

feedback_id: INTEGER, FOREIGN KEY (feedback_id) REFERENCES feedback(id)

user_email: TEXT NOT NULL

UNIQUE (feedback_id, user_email) to enforce one vote per user per item.

comments table:

id: INTEGER PRIMARY KEY AUTOINCREMENT

feedback_id: INTEGER, FOREIGN KEY (feedback_id) REFERENCES feedback(id)

user_email: TEXT NOT NULL

comment_text: TEXT NOT NULL

created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP

2. API Endpoints
Implement the following RESTful API endpoints:

GET /api/feedback

Action: Fetches all feedback items.

Logic: For each feedback item, calculate the total upvote count and the total comment count.

Response: Return a JSON array of feedback objects. Each object should include id, title, description, user_email, created_at, upvote_count, and comment_count. The entire list must be sorted by upvote_count in descending order.

POST /api/feedback

Action: Submits a new feedback item.

Request Body: { "title": "string", "description": "string", "user_email": "string" }

Validation:

Ensure title, description, and user_email are not empty.

Validate that user_email is in a proper email format.

Response: Return the newly created feedback object with a 201 Created status code.

POST /api/feedback/:id/upvote

Action: Adds an upvote to a specific feedback item.

Request Body: { "user_email": "string" }

Logic:

Check if the user's email has already upvoted this feedback ID in the upvotes table.

If not, add a new entry to the upvotes table.

If they have already voted, return an error.

Response: On success, return a success message and the new total upvote count. On failure (already voted), return a 409 Conflict status with an error message.

POST /api/feedback/:id/comments

Action: Adds a comment to a specific feedback item.

Request Body: { "user_email": "string", "comment_text": "string" }

Validation: Ensure user_email and comment_text are not empty.

Response: Return the newly created comment object.

GET /api/feedback/:id/comments

Action: Fetches all comments for a specific feedback item.

Response: Return a JSON array of all comments for the given feedback_id, sorted by created_at (oldest first).

Frontend (Client) Requirements
1. Main View (Feedback List)
Layout:

At the top, display a form to submit new feedback. The form should have fields for Title, Description, and User Email.

Below the form, display the list of all feedback items fetched from the backend.

Feedback Item Display:

Each item in the list must clearly display its title, description, upvote count, and comment count.

Each item must have an "Upvote" button.

Functionality:

Sorting: The list must be automatically displayed sorted by upvote count (most popular first).

Submission: Submitting the form should call the POST /api/feedback endpoint and refresh the feedback list to show the new entry.

Input Validation: Implement basic frontend validation (e.g., required fields, email format) before submitting.

2. Upvoting Interaction
When a user clicks the "Upvote" button on an item, prompt them to enter their email address (a simple prompt() dialog is sufficient).

Use this email to call the POST /api/feedback/:id/upvote endpoint.

Update the UI to reflect the new upvote count.

If the API returns an error (e.g., already voted), display an alert to the user.

3. Comments View (Modal or Separate Page)
Clicking on a feedback item's title or a "View Comments" button should open a view to see and add comments for that specific item.

Display: Show the selected feedback item's full title and description at the top. Below it, list all existing comments (fetched from GET /api/feedback/:id/comments), showing the commenter's email and the comment text.

Add Comment Form: Include a simple form with fields for User Email and Comment Text to allow users to add new comments. Submitting this form should call POST /api/feedback/:id/comments and refresh the comment list.

General Instructions
Project Structure: Organize the project into two main folders: /client for the React app and /server for the Node.js/Express app.

Error Handling: Implement basic error handling. The backend should return appropriate HTTP status codes (e.g., 400 for bad input, 404 for not found), and the frontend should display user-friendly messages or alerts for these errors.

User Perspective: Ensure the entire workflow is intuitive from a user's perspective. A user should be able to land on the page, understand how to add feedback, and how to interact with existing feedback without confusion.

Prompt-3
the ui is very plain and simple, make it more pleasing.
 
 PROMPT-4
 Project Finale: Implement Feedback Statuses and Advanced Sorting

Overall Objective:
Finalize the application by adding a system for admins to assign a status to each feedback item (e.g., "Planned", "In Progress"). Also, provide all users with options to sort the feedback list by different criteria. This will complete the feedback lifecycle and enhance user navigation.

Backend (Server) Requirements
1. Database Schema Update (SQLite)

Modify the feedback table:

Add a new column: status TEXT DEFAULT 'Open'.

This column will hold the current state of the feedback item.

2. API Endpoint Modifications

PUT /api/feedback/:id (Admin Only)

Action: Enhance this existing endpoint to allow admins to update the status in addition to the title and description.

Request Body: { "title": "string", "description": "string", "status": "string" } (All fields should be optional).

Validation: Ensure the provided status is one of a predefined list (e.g., 'Open', 'Planned', 'In Progress', 'Completed').

GET /api/feedback (Public)

Action: Modify this endpoint to accept a sortBy query parameter.

Logic:

The query will look like /api/feedback?sortBy=upvotes or /api/feedback?sortBy=newest.

If sortBy=newest, sort the results by created_at in descending order.

If sortBy=upvotes (or if the parameter is omitted), use the existing logic to sort by upvote_count in descending order.

Response: Return the appropriately sorted list of feedback items.

Frontend (Client) Requirements
1. UI for Sorting

Element: Add a simple dropdown menu or a set of buttons above the feedback list.

Options:

"Most Popular" (this will be the default)

"Newest"

Functionality: When a user selects an option, re-fetch the feedback list by calling the GET /api/feedback endpoint with the corresponding sortBy query parameter (?sortBy=upvotes or ?sortBy=newest) and update the view with the newly sorted data.

2. UI for Feedback Status

Display Status Badge:

On the main feedback list, display the status of each item clearly.

Use a small, colored badge or tag next to the feedback title for visual distinction (e.g., blue for 'Open', yellow for 'In Progress', green for 'Completed').

Admin Status Editor:

In the "Edit Feedback" modal that only admins can access, add a dropdown menu (<select>) field for the status.

Populate this dropdown with the allowed statuses ('Open', 'Planned', 'In Progress', 'Completed').

When the admin saves their changes, the updated status should be sent to the PUT /api/feedback/:id endpoint.

Prompt - 5
Project Refinement: Integrate Inline Comments

Overall Objective:
Refactor the frontend application to display the comments section directly underneath its corresponding feedback item, rather than in a separate view or modal. This will create a more cohesive and intuitive user experience.

This is a frontend-only task. The backend API is already sufficient.

Frontend (Client) Requirements
1. State Management Changes:

Introduce a new state variable to track which feedback item's comments are currently visible (e.g., const [openCommentsId, setOpenCommentsId] = useState(null);).

Modify the state that stores comments to be an object, where keys are the feedback_id and values are the array of comments for that feedback (e.g., const [comments, setComments] = useState({});).

2. Modify the "View Comments" Button:

This button should no longer open a modal or navigate to a new page.

It should now function as a toggle.

On the first click: It should call the GET /api/feedback/:id/comments endpoint to fetch the comments and set openCommentsId to the current feedback item's ID, revealing the comment section.

On subsequent clicks for the same item: It should simply toggle the visibility by setting openCommentsId to the item's ID or null.

3. Inline Rendering Logic:

Inside the main feedbackList.map() function, immediately after rendering a feedback item's div, add a conditional block.

This block should check if openCommentsId matches the current feedback item's ID (openCommentsId === f.id).

If true, render the following components directly underneath the feedback item:

A list of all fetched comments for that item.

The form for adding a new comment.

4. Update "Add Comment" Functionality:

When a user submits a new comment, after the POST request is successful, the new comment should be instantly added to the state (comments[feedbackId]) to refresh the inline list without needing a full page reload.
5. Add a button to change theme
Light and Dark theme can be toggled.